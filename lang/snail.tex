\documentclass{jsarticle}
\usepackage{amssymb,amsmath}
\usepackage{bcprules}
\usepackage{multicol}


\title{The Definition of Snail Programming Language}
\author{letexpr}

\newcommand{\bnfdef}{::=}
\newcommand{\bs}{\boldsymbol}
\newlength{\len}
\settowidth{\len}{$\bnfdef$}
\newcommand{\bnfor}{\makebox[\len]{$|$}}

\begin{document}
\maketitle

\section{はじめに}

Snailは静的型付けの関数型プログラミング言語である.\\

主な特徴として,
\begin{itemize}
  \item Bounded Linear Typeによるリソースの制御
  \item Effect System / Coeffect System (未実装)
  \item 軽量な依存型 (indexed type) (未実装)
\end{itemize}

が挙げられる.\\

本文ではSnailについてCore言語を定義し,Core言語への脱糖規則,Core言語の型付け規則,操作的意味論を定義することによりSnailに定義を与える.\\

本文中ではメタ変数として以下のようなものを用いる.
\begin{itemize}
  \item $\Gamma , \Delta , \Theta\ \cdots\ \mbox{型環境上を動くメタ変数}$.
  \item $A,B,C \cdots\ \mbox{型の上を動くメタ変数.}$
  \item $Ac,Bc,Cc \cdots\ \mbox{コンストラクタ上を動くメタ変数.}$
  \item $x,y,z \cdots\ \mbox{変数上を動くメタ変数.}$
  \item $p,q,r \cdots\ \mbox{resource semiring上を動くメタ変数.}$
  \item $e \cdots\ \mbox{項の上を動くメタ変数.}$
  \item $s\ \cdots\ \mbox{文字列リテラル上を動くメタ変数.}$
  \item $n\ \cdots\ \mbox{自然数上を動くメタ変数.}$
  \item $i\ \cdots\ \mbox{整数上を動くメタ変数.}$
  \item $f\ \cdots\ \mbox{小数上を動くメタ変数.}$
  \item $b\ \cdots\ \mbox{論理値リテラル上を動くメタ変数.}$
\end{itemize}

\newpage

\section{Snailの構文定義}

EBNF記法を用いてSnailの具象構文を以下に示す.

\begin{eqnarray*}
  \mbox{toplevel} &\bnfdef& \mbox{let}\ [ \mbox{rec} ]\ \mbox{x}\ \{ \mbox{y}\ [\ \colon\ \langle \mbox{type} \rangle ] \} \colon \langle \mbox{type} \rangle = \langle \mbox{term} \rangle\ \{ \langle \mbox{mutual-recursion-let} \rangle \} \\
  &\bnfor& \mbox{typedef\ A}\ = [\ |\ ]\ \{ \langle \mbox{Ac}\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle\ |\ \}\ \langle \mbox{Bc}\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle\ \{ \langle \mbox{mutual-recursion-type} \rangle \} \\ \\
  \mbox{mutual-recursion-type} &\bnfdef& \mbox{and\ A}\ = [\ |\ ]\ \{ \langle \mbox{Ac}\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle\  |\ \}\ \langle \mbox{Bc}\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle \\ \\
  \mbox{type} &\bnfdef& \langle \mbox{type} \rangle \rightarrow \langle \mbox{type} \rangle \\
  &\bnfor& !\ \mbox{'['}\ \langle \mbox{expmod} \rangle\ \mbox{']'}\ \mbox{'\{'}\ \langle \mbox{type} \rangle\ \mbox{'\}'} \\
  &\bnfor& \langle \mbox{type} \rangle\ \langle \mbox{type} \rangle \\
  &\bnfor&\mbox{'('}\ \langle \mbox{type} \rangle\ \mbox{')'} \\
  &\bnfor& \mbox{A} \\ \\
  \mbox{expmod} &\bnfdef& \mbox{n} \bnfor \infty \\ \\
  \mbox{pattern} &\bnfdef& \langle \mbox{pattern} \rangle\ \langle \mbox{pattern} \rangle \\
  &\bnfor& \langle \mbox{pattern} \rangle\ \mbox{binop}\ \langle \mbox{pattern} \rangle \\
  &\bnfor& \mbox{'('}\ \langle \mbox{pattern} \rangle\ \mbox{')'} \\
  &\bnfor& \mbox{x} \bnfor \mbox{Ac}\\
  &\bnfor& list \hspace{20pt} \mbox{(組み込みリストの構文糖衣)} \\
  &\bnfor& [\ ] \\
  &\bnfor& \_ \\ \\
  \mbox{mutual-recursion-let} &\bnfdef& \mbox{and\ x}\ \{ \mbox{y}\ [\ \colon\ \langle \mbox{type} \rangle ] \}\ \colon\ \langle \mbox{type} \rangle = \langle \mbox{term} \rangle \\ \\
  \mbox{term} &\bnfdef& \langle \mbox{term} \rangle\ \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{let}\ [ \mbox{rec} ]\ \mbox{x}\ \{ \mbox{y}\ [\ \colon\ \langle \mbox{type} \rangle ] \} \colon \langle \mbox{type} \rangle = \langle \mbox{term} \rangle\ \{ \langle \mbox{mutual-recursion-let} \rangle \}\ \mbox{in}\ \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{fun}\ \{ \mbox{x}\ [\ \colon\ \langle \mbox{type} \rangle ] \}\ \rightarrow \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{match}\ \langle \mbox{term} \rangle\ \mbox{with}\ [\ |\ ]\ \{ \langle \mbox{pattern} \rangle \rightarrow \langle \mbox{term} \rangle\ |\ \}\ \langle \mbox{pattern} \rangle \rightarrow \langle \mbox{term} \rangle\\
  &\bnfor& \mbox{if}\ \langle \mbox{term} \rangle\ \mbox{then}\ \langle \mbox{term} \rangle\ \mbox{else}\ \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{fix}\ \mbox{x} . \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{'('}\ \langle \mbox{term} \rangle\ [\ \colon \langle \mbox{type} \rangle]\ \mbox{')'}\\
  &\bnfor& !\ \langle \mbox{term} \rangle\\
  &\bnfor& \mbox{i} \bnfor \mbox{f} \bnfor \mbox{s} \bnfor \mbox{b} \bnfor \mbox{x} \bnfor \mbox{Ac} \bnfor [\ ] \bnfor \mbox{list} \\
\end{eqnarray*}

\newpage

\section{SnailのCore言語}

SnailのCore言語はSnailのプログラムを脱糖する事により得ることができる.

\subsection{Core言語の構文}

Core言語は次のような構文を持つ.

\begin{eqnarray*}
  \mbox{e} &\bnfdef& \mbox{let}\ \mbox{!x} = e_1\ in\ e_2  \\
  &\bnfor& \mbox{i} \bnfor \mbox{f} \bnfor \mbox{s} \bnfor \mbox{b} \bnfor \mbox{x} \bnfor \mbox{!e}  \\
  &\bnfor& \mbox{match}\ \mbox{e}\ \mbox{with}\ \{  \mbox{pat}  \rightarrow  \mbox{e}\ |\ \}\ \mbox{pat}  \rightarrow  \mbox{e} \\
  &\bnfor& e_1\ e_2 \bnfor \lambda \mbox{x} . \mbox{e} \bnfor \mbox{fix}\ \mbox{x} . \mbox{e}\\ \\
  \mbox{pat} &\bnfdef& pat_1\ pat_2 \bnfor \mbox{x}
\end{eqnarray*}

\subsection{Core言語の型システム}

Core言語の型付け規則を次に示す.



\subsubsection{Contextと演算の定義\\}

Core言語でのContextを次のように定義する.

\begin{center}
  $\Gamma \bnfdef \Phi \bnfor \Gamma,x\ \colon A \bnfor \Gamma,x \colon [A]_p$
\end{center}

また,Context間の加算\ $+$\ を次のように定義する.

\begin{eqnarray*}
  \Phi + \Delta &=& \Delta \\
  (x\ \colon [A]_p,\Gamma) + (x\ \colon [A]_q,\Delta) &=& x\ \colon [A]_{p+q},(\Gamma + \Delta) \\
  (x\ \colon [A]_p,\Gamma) + \Delta &=& x\ \colon [A]_p,(\Gamma + \Delta) \hspace{15pt} \mbox{if}\ x \notin \Delta \\
  (x\ \colon A,\Gamma) + \Delta &=& x\ \colon A,(\Gamma + \Delta) \hspace{15pt} \mbox{if}\ x \notin \Delta \\
\end{eqnarray*}

同様に,Context間の減算\ $-$\ を次のように定義する.

\begin{eqnarray*}
  \Delta - \Phi &=& \Delta \\
  (x\ \colon [A]_p,\Gamma) - (x\ \colon [A]_q,\Delta) &=& x\ \colon [A]_{p-q},(\Gamma - \Delta) \hspace{15pt} \mbox{if}\ p \geq q \\
  (x\ \colon [A]_p,\Gamma) - \Delta &=& x\ \colon [A]_p,(\Gamma - \Delta) \hspace{15pt} \mbox{if}\ x \notin \Delta \\
  (x\ \colon A,\Gamma) - \Delta &=& x\ \colon A,(\Gamma - \Delta) \hspace{15pt} \mbox{if}\ x \notin \Delta \\
\end{eqnarray*}

同様に,Contextと自然数の乗算\ $\star$\ を次のように定義する.

\begin{eqnarray*}
  r \star \Phi &=& \Phi \\
  r \star (x\ \colon [A]_p,[\Gamma]) &=& x\ \colon [A]_{r \star p},r \star [\Gamma] \\
\end{eqnarray*}

$[\Gamma]$\ と表記した際,Context\ $\Gamma$\ 内には線形な変数は含まれない.

\subsubsection{部分型付け規則}

\begin{multicols}{2}
  \infrule[o-i]{}{
    A <: A
  }

  \infrule[o-b]{
  A <: B \hspace{10pt} q \preceq p
  }{
  !_{p} A <: !_{q} B
  }

  \infrule[o-l]{
    A' <: A \hspace{10pt} B <: B'
  }{
    A \multimap B <: A' \multimap B'
  }

  \infrule[o-d]{
  A <: B \hspace{10pt} q \preceq p
  }{
  [ A ]_{p} <: [ B ]_{q}
  }

  \infrule[o-ic]{}{
    \Gamma <: \Gamma
  }

  \infrule[o-c]{
    \Gamma <: \Delta \hspace{10pt} A <: B
  }{
    \Gamma , x\ \colon B <: \Delta , x\ \colon A
  }
\end{multicols}

\subsubsection{型付け規則}

\begin{multicols}{2}
  \infrule[int]{}{
    \vdash i\ \colon \mbox{Int}
  }

  \infrule[float]{}{
    \vdash f\ \colon \mbox{Float}
  }

  \infrule[string]{}{
    \vdash s\ \colon \mbox{String}
  }

  \infrule[bool]{}{
    \vdash b\ \colon \mbox{Bool}
  }

  \infrule[id]{}{
    x\ \colon A \vdash x\ \colon A
  }

  \infrule[pr]{
    [ \Gamma ] \vdash e\ \colon B
  }{
    r \star [ \Gamma ] \vdash ! e\ \colon !_r B
  }

  \infrule[der]{
    \Gamma , x\ \colon A \vdash e\ \colon B
  }{
    \Gamma , x\ \colon [ A ]_1 \vdash e\ \colon\ B
  }

  \infrule[sub]{
    \Delta \vdash e\ \colon B \hspace{15pt} \Gamma <: \Delta
  }{
    \Gamma , \Theta \vdash e\ \colon B
  }

  \infrule[abs]{
    \Gamma , x\ \colon A \vdash e\ \colon B
  }{
    \Gamma \vdash \lambda x.e\ \colon A \multimap B
  }

  \infrule[app]{
    \Gamma \vdash e\ \colon A \multimap B \hspace{15pt} \Delta \vdash e'\ \colon A
  }{
    \Gamma + \Delta \vdash e\ e'\ \colon B
  }

  \infrule[fix]{
    [ \Gamma ] , x\ \colon [ A ]_p \vdash e\ \colon A \hspace{15pt} 1 + p \star q \preceq q
  }{
    q \star [ \Gamma ] \vdash \mbox{fix}\ x.e\ \colon A
  }

  \infrule[let]{
    \Gamma \vdash e\ \colon !_r A \hspace{15pt} \Delta , x\ \colon [ A ]_r \vdash e'\ \colon B
  }{
    \Gamma + \Delta \vdash \mbox{let}\ !x = e\ \mbox{in}\ e'\ \colon B
  }

\end{multicols}

\newpage

\subsubsection{アルゴリズム的型付け規則}

\begin{multicols}{2}
  \infrule[int]{}{
    \vdash i\ \downarrow\ \mbox{Int} ; \phi
  }
  \infrule[float]{}{
    \vdash f\ \downarrow\ \mbox{Float} ; \phi
  }
  \infrule[string]{}{
    \vdash s\ \downarrow\ \mbox{String} ; \phi
  }
  \infrule[bool]{}{
    \vdash b\ \downarrow\ \mbox{Bool} ; \phi
  }

  \infrule[id]{}{
    x\ \colon A \vdash x\ \uparrow\ A ; x\ \colon [A]_1
  }
  \infrule[pr]{
  [ \Gamma_1 ] \vdash e\ \downarrow\ B  ; [ \Gamma_2 ]
  }{
  r \star [ \Gamma_1 ] \vdash\ !e\ \downarrow\ !_r B ; r \star [ \Gamma_2 ]
  }
  \infrule[der]{
    \Gamma_1 , x\ \colon A \vdash e\ \downarrow\ B ; \Gamma_2
  }{
    \Gamma_1 , x\ \colon [A]_1 \vdash e\ \downarrow\ B ; \Gamma_2
  }
  \infrule[sub]{
    \Delta \vdash e\ \downarrow\ B ; \Gamma_2 \hspace{15pt} \Gamma_1 <: \Delta
  }{
    \Gamma_1 , \Theta \vdash e\ \downarrow\ B ; \Gamma_2
  }
  \infrule[abs]{
    \Gamma_1 , x\ \colon A \vdash e\ \downarrow\ B ; \Gamma_2
  }{
    \Gamma_1 \vdash \lambda x.e\ \downarrow\ A \multimap B ; \Gamma_2
  }
  \infrule[app]{
    \Gamma_1 \vdash e\ \uparrow\ A \multimap B ; \Gamma_2 \hspace{15pt} \Gamma_1 - \Gamma_2 \vdash e'\ \downarrow\ B ; \Gamma_3
  }{
    \Gamma_1 \vdash e\ e'\ \downarrow\ B ; \Gamma_2 + \Gamma_3
  }
  \infrule[fix]{
  [\Gamma_1] , x\ \colon [A]_p \vdash e\ \downarrow\ A;[\Gamma_2] \hspace{15pt} 1 + p \star q \preceq q
  }{
  q \star [\Gamma_1] \vdash \mbox{fix}\ x.e\ \downarrow\ A ; q \star [\Gamma_2]
  }
  \infrule[let]{
    \Gamma_1 \vdash e\ \uparrow\ !_r A;\Gamma_2 \hspace{15pt} \Gamma_1 - \Gamma_2 ,x\ \colon [A]_r \vdash e'\ \downarrow\ B ; \Gamma_3
  }{
    \Gamma_1 \vdash \mbox{let}\ !x = e\ \mbox{in}\ e'\ \downarrow\ B ; \Gamma_2 + \Gamma_3
  }

\end{multicols}

\section{参考文献}



\end{document}