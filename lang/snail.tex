\documentclass{jsarticle}
\usepackage{amssymb,amsmath}
\usepackage{lscape}
\usepackage{bcprules}
\usepackage{multicol}
\usepackage{stackengine}
\usepackage{bussproofs}

\title{Snail Programming Language}
\author{Nakamura Aoi}

\newcommand{\bnfdef}{::=}
\newcommand{\bs}{\boldsymbol}
\newlength{\len}
\settowidth{\len}{$\bnfdef$}
\newcommand{\bnfor}{\makebox[\len]{$|$}}

\begin{document}
\maketitle

\section{はじめに}

Snailは静的型付けの関数型プログラミング言語である.\\

主な特徴として,
\begin{itemize}
  \item Bounded Linear Typeによるリソースの制御
  \item Effect System / Coeffect System (未実装)
  \item 軽量な依存型 (indexed type) (未実装)
\end{itemize}

が挙げられる.\\

本文ではSnailについてCore言語を定義し,Core言語への脱糖規則,Core言語の型付け規則,操作的意味論を定義することによりSnailに定義を与える.\\

本文中ではメタ変数として以下のようなものを用いる.
\begin{itemize}
  \item $\Gamma , \Delta , \Theta\ \cdots\ \mbox{型環境上を動くメタ変数}$.
  \item $A,B \cdots\ \mbox{型の上を動くメタ変数.}$
  \item $X \cdots\ \mbox{型変数上を動くメタ変数.}$
  \item $K \cdots\ \mbox{コンストラクタ上を動くメタ変数.}$
  \item $x,y,z \cdots\ \mbox{変数上を動くメタ変数.}$
  \item $p \cdots \mbox{パターン上を動くメタ変数.}$
  \item $r,s,t \cdots\ \mbox{resource semiring上を動くメタ変数.}$
  \item $e \cdots\ \mbox{項の上を動くメタ変数.}$
  \item $n\ \cdots\ \mbox{自然数上を動くメタ変数.}$
  \item $l\ \cdots\ \mbox{バリアントにおけるラベル上を動くメタ変数.}$
  \item $i,j\ \cdots\ \mbox{メタ自然数上を動くメタ変数.}$
\end{itemize}

\newpage

\section{Snailの構文定義}

EBNF記法を用いてSnailの具象構文を以下に示す.

\begin{eqnarray*}
  \mbox{toplevel} &\bnfdef& \mbox{let}\ [ \mbox{rec} ]\ x\ \{ y\ [\ \colon\ \langle \mbox{type} \rangle ] \} \colon \langle \mbox{type} \rangle = \langle \mbox{term} \rangle\ \{ \langle \mbox{mutual-recursion-let} \rangle \} \\
  &\bnfor& \mbox{typedef}\ A\ = [\ |\ ]\ \{ \langle K\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle\ |\ \}\ \langle K\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle\ \{ \langle \mbox{mutual-recursion-type} \rangle \} \\ \\
  \mbox{mutual-recursion-type} &\bnfdef& \mbox{and}\ A\ = [\ |\ ]\ \{ \langle K\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle\  |\ \}\ \langle K\ [ \mbox{of}\ \langle \mbox{type} \rangle ] \rangle \\ \\
  \mbox{type} &\bnfdef& \langle \mbox{type} \rangle \rightarrow \langle \mbox{type} \rangle \\
  &\bnfor& !\ \mbox{'['}\ \langle \mbox{expmod} \rangle\ \mbox{']'}\ \mbox{'\{'}\ \langle \mbox{type} \rangle\ \mbox{'\}'} \\
  &\bnfor&\mbox{'('}\ \langle \mbox{type} \rangle\ \mbox{')'} \\
  &\bnfor& A \\ \\
  \mbox{expmod} &\bnfdef& n \bnfor \infty \\ \\
  \mbox{pattern} &\bnfdef& \langle \mbox{pattern} \rangle\ \mbox{binop}\ \langle \mbox{pattern} \rangle \\
  &\bnfor& \mbox{'('}\ \langle \mbox{pattern} \rangle\ \mbox{')'} \\
  &\bnfor& x \bnfor K\ ( \{ \langle \mbox{pattern} \rangle\ ,\} \langle \mbox{pattern} \rangle)　\\
  &\bnfor& \mbox{list} \hspace{20pt} \mbox{(組み込みリストの構文糖衣)} \\
  &\bnfor& \_ \\ \\
  \mbox{mutual-recursion-let} &\bnfdef& \mbox{and}\ x\ \{ y\ [\ \colon\ \langle \mbox{type} \rangle ] \}\ \colon\ \langle \mbox{type} \rangle = \langle \mbox{term} \rangle \\ \\
  \mbox{term} &\bnfdef& \langle \mbox{term} \rangle\ \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{let}\ [ \mbox{rec} ]\ x\ \{ y\ [\ \colon\ \langle \mbox{type} \rangle ] \} \colon \langle \mbox{type} \rangle = \langle \mbox{term} \rangle\ \{ \langle \mbox{mutual-recursion-let} \rangle \}\ \mbox{in}\ \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{fun}\ \{ x\ [\ \colon\ \langle \mbox{type} \rangle ] \}\ \rightarrow \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{case}\ \langle \mbox{term} \rangle\ \mbox{of}\ [\ |\ ]\ \{ \langle \mbox{pattern} \rangle \rightarrow \langle \mbox{term} \rangle\ |\ \}\ \langle \mbox{pattern} \rangle \rightarrow \langle \mbox{term} \rangle\\
  &\bnfor& \mbox{if}\ \langle \mbox{term} \rangle\ \mbox{then}\ \langle \mbox{term} \rangle\ \mbox{else}\ \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{fix}\ x . \langle \mbox{term} \rangle \\
  &\bnfor& \mbox{fold}\ t \bnfor \mbox{unfold}\ t \\
  &\bnfor& \mbox{'('}\ \langle \mbox{term} \rangle\ [\ \colon \langle \mbox{type} \rangle]\ \mbox{')'}\\
  &\bnfor& !\ \langle \mbox{term} \rangle\\
  &\bnfor& K\ ( \{ \langle \mbox{term} \rangle,\} \langle \mbox{term} \rangle)　\\
  &\bnfor& x \bnfor \mbox{list} \\
\end{eqnarray*}

\newpage

\section{SnailのCore言語}

SnailのCore言語はSnailのプログラムを脱糖する事により得ることができる. \\
Core言語は次のような性質を持つ.

\begin{itemize}
  \item パターン$p$は重複せず全ての条件を網羅している.
  \item resource semiringとしてextended natural numbers semiring $(\mathbb{N} \cup \{ \infty \},+,0,\star,1,\leq)$を用いる.
  \item コンストラクタ $K$が持つべき型は型環境に追加されている.
\end{itemize}

\subsection{Core言語の構文}

Core言語は次のような構文を持つ.

\begin{eqnarray*}
  e &\bnfdef& \mbox{let}\ x = e_1\ \mbox{in}\ e_2  \\
  &\bnfor& ( e_1 , e_2 ,\dots, e_n) \bnfor x \bnfor K  \\
  &\bnfor& \mbox{case}\ e\ \mbox{of}\ \{ p_i  \rightarrow  e_i\ \}_{i = 1}^{n} \\
  &\bnfor& e_1\ e_2 \bnfor \lambda x . e \bnfor \mbox{fix}\ x . e \\
  &\bnfor& \mbox{fold}\ t \bnfor \mbox{unfold}\ t \\ \\
  p &\bnfdef& K\ (x_1,x_2,\dots,x_n) \\ \\
  \Gamma &\bnfdef& \emptyset  \bnfor \Gamma,x \colon A^r \\ \\
  A^r &\bnfdef& \mu X.A^r \bnfor A \xrightarrow{r} A \bnfor (A \times A \times \cdots \times A)^r \bnfor \{ l_1 \colon A_1 + \dots + l_n \colon A_n \}^r \bnfor X^r \bnfor ()^r\\
\end{eqnarray*}

$A^r$の定義に見られるように,現れる型のresource semiringがどんなものでも良い場合,resource semiringを省略して表記することがある.

\subsection{Core言語の型システム}

Core言語の型付け規則を次に示す.

\subsubsection{Context間の演算の定義}

Context間の加算\ $+$\ を次のように定義する.

\begin{eqnarray*}
  \emptyset + \Delta &=& \Delta \\
  (x\ \colon A^r,\Gamma) + (x\ \colon A^s,\Delta) &=& x\ \colon A^{r + s},(\Gamma + \Delta) \\
  (x\ \colon A^r,\Gamma) + \Delta &=& x\ \colon A^r,(\Gamma + \Delta) \hspace{15pt} \mbox{if}\ x \notin \mbox{dom}(\Delta) \\
\end{eqnarray*}

\newpage

同様に,Contextとresource semiringの乗算\ $\star$\ を次のように定義する.

\begin{eqnarray*}
  r \star \emptyset &=& \emptyset \\
  r \star (x\ \colon A^s,\Gamma) &=& x\ \colon A^{r \star s},r \star \Gamma \\
\end{eqnarray*}

\subsubsection{部分型付け規則}

\begin{multicols}{2}
  \infrule[o-i]{}{
    A <: A
  }

  \infrule[o-b]{
    A <: B \hspace{10pt} r \preceq s
  }{
    A^s <: B^r
  }

  \infrule[o-l]{
    A_1 <: A_2 \hspace{10pt} B_1 <: B_2
  }{
    A_2 \rightarrow B_1 <: A_1 \rightarrow B_2
  }

  \infrule[o-ic]{}{
    \Gamma <: \Gamma
  }

  \infrule[o-c]{
    \Gamma <: \Delta \hspace{10pt} A <: B
  }{
    \Gamma , x\ \colon A <: \Delta , x\ \colon B
  }

  \infrule[o-r]{
    A <: B
  }{
    \mu X . A <: \mu X . B
  }
\end{multicols}

\subsubsection{型付け規則\\}

\begin{multicols}{2}

  \infrule[var]{}{
    x\ \colon A \vdash x\ \colon A
  }

  \infrule[con]{}{
    K\ \colon A \vdash K\ \colon A
  }

  \infrule[pr]{
    \Gamma \vdash e\ \colon B^1
  }{
    r \star \Gamma \vdash e\ \colon B^r
  }

  \infrule[sub]{
    \Delta \vdash e\ \colon B \hspace{15pt} \Gamma <: \Delta
  }{
    \Gamma , \Theta \vdash e\ \colon B
  }

  \infrule[abs]{
    \Gamma , x\ \colon A \vdash e\ \colon B
  }{
    \Gamma \vdash \lambda x.e\ \colon A \xrightarrow{1} B
  }

  \infrule[app]{
    \Gamma \vdash e\ \colon A \xrightarrow{1} B \hspace{15pt} \Delta \vdash e'\ \colon A
  }{
    \Gamma + \Delta \vdash e\ e'\ \colon B
  }

  \infrule[fix]{
    \Gamma , x\ \colon A^r \vdash e\ \colon A^1 \hspace{15pt} 1 + r \star s \preceq s
  }{
    s \star \Gamma \vdash \mbox{fix}\ x.e\ \colon A^1
  }

  \infrule[let]{
    \Gamma \vdash e\ \colon A^r \hspace{15pt} \Delta , x\ \colon A^r \vdash e'\ \colon B
  }{
    \Gamma + \Delta \vdash \mbox{let}\ x = e\ \mbox{in}\ e'\ \colon B
  }

  \infrule[fold]{
    A = \mu X . B \hspace{15pt} \Gamma \vdash t\ \colon [X \mapsto B] A
  }{
    \Gamma \vdash \mbox{fold}\ t\ \colon A
  }

  \infrule[unfold]{
    A = \mu X.B \hspace{15pt} \Gamma \vdash t\ \colon A
  }{
    \Gamma \vdash \mbox{unfold}\ t\ \colon [X \mapsto A] B
  }

\end{multicols}

\infrule[tuple]{
  \Gamma_1 \vdash e_1\ \colon A_1 \hspace{15pt} \Gamma_2 \vdash e_2\ \colon A_2\ \cdots\ \Gamma_n \vdash e_n\ \colon A_n
}{
  \Gamma_1 + \Gamma_2 + \cdots + \Gamma_n \vdash (e_1,e_2,\dots,e_n)\ \colon (A_1 \times A_2 \times \cdots \times A_n)^1
}

\infrule[case]{
\Gamma \vdash e\ \colon A \hspace{15pt} e \parallel p_i \Rightarrow \Gamma_i \hspace{15pt} \Delta + \Gamma_i \vdash e_i\ \colon B
}{
\Gamma + \Delta \vdash \mbox{case}\ e\ \mbox{of}\ \{ p_i \rightarrow e_i \}_{i=1}^{n}\ \colon B
}

パターンマッチについての型付け規則を定義するために新しく三項関係 $e \parallel p \Rightarrow \Gamma$を導入する.これは,パターン $p$を用いて$e$を分解したとき,
新たにContext $\Gamma$が結果として導入されることを表している.

\begin{center}
\end{center}

\subsubsection{アルゴリズム的型付け規則\\}

アルゴリズム的型付け規則を与えるために,context difference operator $\div$を次のように定義する.

\begin{center}
  $\Gamma_1,x\ \colon A^s,\Gamma_2 \div x = \Gamma_1,\Gamma_2$
\end{center}

アルゴリズム的型付け規則は,context $\Gamma_1$,項 $e$,型 $A$,未使用のcontext $\Gamma_2$,resource ring及び型変数に関する制約 $C$の関係
\begin{multicols}{2}
  \begin{center}
    $\Gamma_1 \vdash e\ \uparrow\ A \vartriangleright \Gamma_2\ [C]$\\
  \end{center}
  \begin{center}
    $\Gamma_1 \vdash e\ \downarrow\ A \vartriangleright \Gamma_2\ [C]$\\
  \end{center}
\end{multicols}
によって表される.

$\uparrow$はbidirectional typecheckingにおけるsynthesis modeを$\downarrow$はcheck modeを表している.

また,アルゴリズム的型付け規則ではresource semiringに結果が0以上になる範囲で除算を導入する.

\infrule[tuple-$\uparrow$]{
\cfrac{1}{r} \star \Gamma_1 \vdash e_1\ \uparrow\ A_1 \vartriangleright \Gamma_2\ [C_1] \\ \Gamma_2 \vdash e_2\ \uparrow\ A_2 \vartriangleright \Gamma_3\ [C_2]\  \cdots\ \Gamma_n \vdash e_n\ \uparrow\ A_n \vartriangleright \Gamma_{n+1}\ [C_n]
}{
\Gamma_1 \vdash (e_1,e_2,\dots,e_n)\ \uparrow\ ( A_1 \times A_2 \times \cdots \times A_n )^r \vartriangleright \Gamma_{n+1}\ [C_1 \cup \cdots \cup C_n]
}

\infrule[tuple-$\downarrow$]{
\cfrac{1}{r} \star \Gamma_1 \vdash e_1\ \downarrow\ A_1 \vartriangleright \Gamma_2\ [C_1] \\ \Gamma_2 \vdash e_2\ \downarrow\ A_2 \vartriangleright \Gamma_3\ [C_2]\  \cdots\ \Gamma_n \vdash e_n\ \downarrow\ A_n \vartriangleright \Gamma_{n+1}\ [C_n]
}{
\Gamma_1 \vdash (e_1,e_2,\dots,e_n)\ \downarrow\ ( A_1 \times A_2 \times \cdots \times A_n )^r \vartriangleright \Gamma_{n+1}\ [C_1 \cup \cdots \cup C_n]
}

\infrule[var-$\uparrow$]{}{
\Gamma_1,x\ \colon A^r,\Gamma_2 \vdash x\ \uparrow\ A^s \vartriangleright \Gamma_1,x\ \colon A^{r-s},\Gamma_2\ [\{1 \leq s \leq r\}]
}

\infrule[var-$\downarrow$]{}{
\Gamma_1,x\ \colon B^r,\Gamma_2 \vdash x\ \downarrow\ A^s \vartriangleright \Gamma_1,x\ \colon B^{r-s},\Gamma_2\ [\{1 \leq s \leq r,B^r = A^s\}]
}

\infrule[con-$\uparrow$]{}{
\Gamma_1,K\ \colon A,\Gamma_2 \vdash K\ \uparrow\ A \vartriangleright \Gamma_1,K\ \colon A,\Gamma_2\ [\emptyset]
}

\infrule[con-$\downarrow$]{}{
\Gamma_1,K\ \colon A,\Gamma_2 \vdash K\ \downarrow\ A \vartriangleright \Gamma_1,K\ \colon A,\Gamma_2\ [\emptyset]
}

\infrule[app-$\uparrow$]{
\Gamma_1 \vdash e\ \uparrow\ A \xrightarrow{t} B \vartriangleright \Gamma_2\ [C_1] \hspace{15pt} \Gamma_2 \vdash e'\ \downarrow\ A \vartriangleright \Gamma_3\ [C_2]
}{
\Gamma_1 \vdash e\ e'\ \uparrow\ B \vartriangleright \Gamma_3\ [C_1 \cup C_2 \cup \{ 1 \leq t \}]
}

\infrule[app-$\downarrow$]{
\Gamma_1 \vdash e\ \uparrow\ A \xrightarrow{t} B \vartriangleright \Gamma_2\ [C_1] \hspace{15pt} \Gamma_2 \vdash e'\ \downarrow\ A \vartriangleright \Gamma_3\ [C_2]
}{
\Gamma_1 \vdash e\ e'\ \downarrow\ B \vartriangleright \Gamma_3\ [C_1 \cup C_2 \cup \{ 1 \leq t \}]
}

\infrule[abs-$\uparrow$]{
\mbox{fresh}(X,\Gamma,C) \hspace{15pt} \sigma = \mbox{unify}(C) \hspace{15pt} \mbox{NotContainTyvar}(\sigma (X))\\
A = \sigma (X) \hspace{15pt} \cfrac{1}{t} \star \Gamma_1 , x\ \colon X \vdash e\ \uparrow\ B \vartriangleright \Gamma_2\ [C]
}{
\Gamma_1 \vdash \lambda x.e\ \uparrow\ A \xrightarrow{t} B \vartriangleright \Gamma_2 \div x\ [C]
}
\infrule[abs-$\downarrow$]{
\cfrac{1}{t} \star \Gamma_1 , x\ \colon A \vdash e\ \downarrow\ B \vartriangleright \Gamma_2\ [C]
}{
\Gamma_1 \vdash \lambda x.e\ \downarrow\ A \xrightarrow{t} B \vartriangleright \Gamma_2 \div x\ [C]
}

\infrule[let-$\uparrow$]{
\Gamma_1 \vdash e\ \uparrow\ A \vartriangleright \Gamma_2\ [C_1] \hspace{15pt} \Gamma_2 ,x\ \colon A \vdash e'\ \uparrow\ B \vartriangleright \Gamma_3\ [C_2]
}{
\Gamma_1 \vdash \mbox{let}\ x = e\ \mbox{in}\ e'\ \uparrow\ B \vartriangleright \Gamma_3 \div x\ [C_1 \cup C_2]
}
\infrule[let-$\downarrow$]{
\Gamma_1 \vdash e\ \uparrow\ A \vartriangleright \Gamma_2\ [C_1] \hspace{15pt} \Gamma_2 ,x\ \colon A \vdash e'\ \downarrow\ B^s \vartriangleright \Gamma_3\ [C_2]
}{
\Gamma_1 \vdash \mbox{let}\ x = e\ \mbox{in}\ e'\ \downarrow\ B \vartriangleright \Gamma_3 \div x\ [C_1 \cup C_2]
}

\infrule[fix-$\downarrow$]{
\cfrac{1}{s} \star \Gamma_1 , x\ \colon A^r \vdash e\ \downarrow\ A^1 \vartriangleright \Gamma_2\ [C \cup \{ \frac{1 - s}{s} \leq r \}]
}{
\Gamma_1 \vdash \mbox{fix}\ x.e\ \downarrow\ A^s \vartriangleright \Gamma_2\ [C \cup \{ \frac{1 - s}{s} \leq r \}]
}

アルゴリズム的型付け規則を与えるために導入した述語及び関数の定義を示す.

\begin{itemize}
  \item $\mbox{fresh}(X,\Gamma,C) \cdots X\mbox{は}\Gamma\mbox{にも}C\mbox{にも出現しない}$.
  \item $\mbox{NotContainTyvar}(A) \cdots A\mbox{には型変数が含まれない.}$
  \item $\mbox{unify}(C) \cdots$\ $C$を単一化し,得られた代入を返す.
\end{itemize}

\newpage

\subsubsection{アルゴリズム的型付けの例\\}

Consは型$K$についての値コンストラクタであり,型 $A^1 \times A^1 \rightarrow K^1$を持つとする.

\begin{itemize}
  \item $\lambda x . \mbox{Cons}(x,x)$ \\
        \begin{prooftree}
          \AxiomC{$\mbox{TC}(\mbox{Cons}) = A^1 \times A^1 \rightarrow K^1$}
          \AxiomC{\stackanchor{$x\ \colon X_1^{\frac{r_1}{s*t}} \vdash x\ \downarrow\ A^1 \vartriangleright x\ \colon X_1^{\frac{r_1}{s*t} - 1}\ [\{ 1 \leq \frac{r_1}{s*t},X_1 = A\}]$}{$x\ \colon X_1^{\frac{r_1}{s*t} - 1} \vdash x\ \downarrow\ A^1 \vartriangleright x\ \colon X_1^{\frac{r_1}{s*t} - 2}\ [\{1 \leq \frac{r_1}{s*t} - 1,X_1 = A\}]$}}
          \UnaryInfC{$x\ \colon X_1^{\frac{r_1}{s*t}}\vdash (x,x)\ \downarrow\ A^1 \times A^1 \vartriangleright x\ \colon X_1^{\frac{r_1}{s*t} - 2}\ [\{1 \leq \frac{r_1}{s*t},1 \leq \frac{r_1}{s*t} - 1,X_1 = A\}]$}
          \BinaryInfC{$x\ \colon X_1^{r_1}\vdash \mbox{Cons}(x,x)\ \uparrow\ K^s \vartriangleright x\ \colon X_1^{\frac{r_1}{s*t} - 2}\ [\{1 \leq \frac{r_1}{s*t},1 \leq \frac{r_1}{s*t} - 1,X_1 = A\}]$}
          \UnaryInfC{$\vdash \lambda x.\mbox{Cons}(x,x)\ \uparrow\ (A^{r_1} \rightarrow K^s)^t \vartriangleright \emptyset\ [\{1 \leq \frac{r_1}{s*t},1 \leq \frac{r_1}{s*t} - 1,X_1 = A\}]$}
        \end{prooftree}
\end{itemize}

\end{document}