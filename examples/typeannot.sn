let f = ((fun x -> (x : a)) : b -> Int)

let g y = (fun x -> (y : Int))

typedef Option a = None | Some of a

let some_2 = (Some 2 : Option Int)

let some_str = (Some "abc" : Option String)

let none = (None : Option a)

let a (b : Int) (c : Int) = b

let b =
  let f (x : Int) = x in
  f 2

let fn = fun (x : Int) -> x

let tuple (x : a * b) =
  match x with
    (a,b) -> b

typedef List a = Nil | Cons of a * List a

let rec map (f : a -> b) (l : List a) =
  match l with
    Nil -> Nil
  | Cons(x,xs) -> Cons(f x,map f xs)

typedef Either (a,b) = Left of a | Right of b

let get_left_int (e : Either (Int,a)) =
  match e with
    Left a -> a

typedef A (a,b,c) = A of a * b * c

let fst_A_int (a : A (Int,x,y)) =
  match a with
    A(x,xs,xxs) -> x

let main = g 2 3